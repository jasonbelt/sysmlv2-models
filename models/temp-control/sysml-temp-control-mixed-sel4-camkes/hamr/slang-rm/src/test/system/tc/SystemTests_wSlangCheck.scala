package tc

import art.Art
import art.scheduling.static._
import org.sireum.Random.Impl.Xoshiro256
import org.sireum._
import tc.Example_TempControl_Inputs_Container_Test_wSlangCheck._
import tc.TempControlMixedSeL4CAmKES.{Fan_fp_ft, StaticSchedulerCust, TempSensor_tsp_tst, TempUnit, Temperature}
import tc.TempControl_Inputs_Container_Profile._
import tc.TempControl_Inputs_Container_SlangCheck._
import tc.TempControlMixedSeL4CAmKES.{Defs, FanAck, FanCmd, Fan_fp_ft, StaticSchedulerCust, TempControl_tcp_tct, TempUnit, Temperature, Fan_fp_ft_SystemTestAPI => Fan, TempControl_tcp_tct_SystemTestAPI => TempControl}

import scala.language.implicitConversions

// Do not edit this file as it will be overwritten if SystemTestArtifactGen is rerun

class SystemTests_wSlangCheck
  extends TempControl_Inputs_Container_SlangCheck {

  //================================================================
  //  S c h e d u l a r     and    S t e p p e r     Configuration
  //================================================================

  // note: this is overriding SystemTestSuite's 'def scheduler: Scheduler'
  //       abstract method
  //var scheduler: StaticScheduler = Schedulers.getStaticSchedulerH(MNone())
  var scheduler: StaticScheduler = Schedulers.getStaticScheduler(
    StaticSchedulerCust.staticSchedule,
    StaticSchedulerCust.domainToBridgeIdMap,
    StaticSchedulerCust.threadNickNames,
    ISZCommandProvider(ISZ()))

  def compute(isz: ISZ[Command]): Unit = {
    scheduler = scheduler(commandProvider = ISZCommandProvider(isz :+ Stop()))

    Art.computePhase(scheduler)
  }

  override def beforeEach(): Unit = {

    val random: Random.Gen64Impl = Random.Gen64Impl(Xoshiro256.create)
    // reset the mocked up fan and temp sensor singleton devices
    // before each test.  The fan is either off or on
    Fan_fp_ft.isOn = random.nextB()

    // Set the temp sensor's lastTemperature such that it will only generate
    // values that will satisfy its integration constraint [-40 .. 122.0]
    val lastTemp = random.nextF32Between(
      f32"-40" + Math.abs(TempSensor_tsp_tst.delta.value),
      f32"122.0" - Math.abs(TempSensor_tsp_tst.delta.value))
    TempSensor_tsp_tst.lastTemperature = Temperature(lastTemp, TempUnit.Fahrenheit)

    // uncomment the following to disable the various guis and to suppress the log streams
    disableLogsAndGuis()

    super.beforeEach()
  }

  //===========================================================
  //  S l a n g   C h e c k    Infrastructure
  //===========================================================

  val maxTests = 100
  var verbose: B = T

  val profile = getDefaultProfile
  profile.currentTemp.set_Config_F32(profile.currentTemp.get_Config_F32(low = Some(50f), high = Some(90f)))

  val configurations: ISZ[SystemTestConfiguration] = ISZ(
    SystemTestConfiguration(
      name = "FanOn",
      description = "If the temperature is above the current set point then the fan should be turned on",
      schema = tc_1HP_script_schema _,
      profile = profile, //etDefaultProfile,
      filter = examplePreStateContainerFilter _,
      property = sysProp_fanOn _,
      componentsOfInterest = ISZ(), // ignore this as it's intended to be used for reporting purposes
      numTests = maxTests
    ),
    /*
    SystemTestConfiguration(
      name = "FanOff",
      description = "If the temperature is below the current set point then the fan should be turned off",
      schema = tc_1HP_script_schema _,
      profile = getDefaultProfile,
      filter = onlyPopulatedFanCmds _,
      property = sysProp_fanOff _,
      componentsOfInterest = ISZ(),
      numTests = maxTests
    ),

     */
    /*
    SystemTestConfiguration(
      name = "test-name", // must be unique and does not contain spaces
      description = "Test description",
      schema = exampleSchema _,
      profile = getDefaultProfile,
      filter = examplePreStateContainerFilter _,
      property = exampleProperty _,
      componentsOfInterest = ISZ(),
      numTests = maxTests
    )
    */
  )

  for (config <- configurations) {
    run(config)
  }

  def run(config: SystemTestConfiguration): Unit = {

    def next: Option[TempControl_Inputs_Container] = {
      try {
        return Some(config.profile.next())
      } catch {
        case e: AssertionError => // SlangCheck was unable to satisfy a datatype's filter
          return None()
      }
    }

    for (i <- 0 until config.numTests) {
      val testName = s"${genTestName(config)}_$i"
      this.registerTest(testName) {
        var retry: B = T
        var j: Z = 0

        while (j < config.profile.numTestVectorGenRetries && retry) {
          if (verbose && j > 0) {
            println(s"Retry $j:")
          }

          next match {
            case Some(container) =>
              if (!config.filter.function(container)) {
                // retry
                assert(T)
              } else {
                assert(config.schema.function(container, config.property.function))
                retry = F
              }
            case _ =>
          }
          j = j + 1
        }
      }
    }
  }

  def tc_1HP_script_schema(input_container: TempControl_Inputs_Container,
                           prop: (TempControl_Inputs_Container, ISZ[TempControl_Outputs_Container]) => B): B = {
    Art.initializePhase(scheduler)

    // ====== Compute ======

    //  ----  r u n   t o   a r b i t r a r y    s y s t e m    s t a t e

    // Abstractly, run the system an arbitrary number of steps

    compute(ISZ(Hstep(2)))

    compute(ISZ(RunToThread("TempControl")))


    // -------------------- inject / observe inputs --------------------
    //   ...eventually, auto-generated from higher-level specification of
    //      injection and observation vectors, along with temporal point
    //      declarations of when to inject and observe
    // -------------------------------------------------------------------

    // inject values
    TempControl.put_currentTemp(input_container.currentTemp)
    TempControl.put_tempChanged(input_container.tempChanged)
    TempControl.put_In_fanError(input_container.fanError)

    // ---------------- trace steps ----------------------

    val preOutputs_container = TempControl_Outputs_Container(
      fanCmd = TempControl.get_api_fanCmd(),
      fanAck = Fan.get_api_fanAck(),
      fanIsOn = Fan_fp_ft.isOn,
      currentFanState = TempControl.get_currentFanState(),
      currentSetPoint = TempControl.get_currentSetPoint())

    // run to end of current hyper-period - and check outputs of selected components
    compute(ISZ(Hstep(1)))

    // ------------------ observe output -- build output observation vector ------------------
    //   ...eventually, auto-generated from higher-level specification of
    //      injection and observation vectors, along with temporal point
    //      declarations of when to inject and observe
    // ---------------------------------------------------------------------------------------

    val postOutputs_container = TempControl_Outputs_Container(
      fanCmd = TempControl.get_api_fanCmd(),
      fanAck = Fan.get_api_fanAck(),
      fanIsOn = Fan_fp_ft.isOn,
      currentFanState = TempControl.get_currentFanState(),
      currentSetPoint = TempControl.get_currentSetPoint())

    // gracefully take system down
    Art.finalizePhase(scheduler)

    // ------------------ check property of collected observations ------------------
    //   ...eventually, auto-generated from higher-level specification of
    //      property evaluation
    // ---------------------------------------------------------------------------------------

    return prop(input_container, ISZ(preOutputs_container, postOutputs_container))
  }


  //===========================================================
  //  P r o p e r t i e s
  //===========================================================

  def sysProp_fanOn(inputs_container: TempControl_Inputs_Container,
                    outputs_containers: ISZ[TempControl_Outputs_Container]): B = {
    val preInjectionState = outputs_containers(0)
    val postInjectionState = outputs_containers(1)
    /*
    val trigger_condition1 =
      !inputs_container.fanError ||
        postInjectionState.fanCmd == preInjectionState.currentFanState

    val triggerCondition2 =
      (inputs_container.fanError || inputs_container.currentTemp.degrees > inputs_container.currentSetPoint.high.degrees) ||
        (preInjectionState.currentFanState == postInjectionState.currentFanState &&
          postInjectionState.fanCmd.isEmpty &&
          preInjectionState.fanIsOn == postInjectionState.fanIsOn)

    val triggerCondition3 =
      (inputs_container.fanError || preInjectionState.currentFanState != FanCmd.Off) ||
        (postInjectionState.currentFanState == FanCmd.On &&
          postInjectionState.fanCmd == FanCmd.On &&
          (postInjectionState.fanAck != FanAck.Ok || postInjectionState.fanIsOn) &&
          (postInjectionState.fanAck != FanAck.Error || preInjectionState.fanIsOn == postInjectionState.fanIsOn)preInjectionState.currentFanState != FanCmd.On)
   */
   // if (!trigger_condition1 || !triggerCondition2 || !triggerCondition3) {
     // assert(T)
    //}
    //return trigger_condition1 && triggerCondition2 && triggerCondition3
    val trigger_condition = !inputs_container.fanError &
      inputs_container.currentTemp.degrees > postInjectionState.currentSetPoint.high.degrees

    val desired_condition =
      postInjectionState.currentFanState == FanCmd.On &&
        postInjectionState.fanCmd.nonEmpty &&
        postInjectionState.fanCmd.get == FanCmd.On &&
        (postInjectionState.fanAck != FanAck.Ok || postInjectionState.fanIsOn) &&
        (postInjectionState.fanAck != FanAck.Error || preInjectionState.fanIsOn == postInjectionState.fanIsOn)

    if (!(!trigger_condition || desired_condition)) {
      assert(T)
    }

    bookKeep(trigger_condition, desired_condition)

    return !trigger_condition || desired_condition
  }

  def sysProp_fanOff(inputs_container: TempControl_Inputs_Container,
                     outputs_container: TempControl_Outputs_Container): B = {
    val trigger_condition = (inputs_container.currentTemp.degrees < outputs_container.currentSetPoint.low.degrees)

    val desired_condition = outputs_container.fanCmd == FanCmd.Off & !Fan_fp_ft.isOn

    return (trigger_condition.->:(desired_condition))
  }

  // a pre-state container filter could prove useful/necessary in order to
  // ensure that the values in the container will satisfy the assume/requires clause
  // of a component in the system that will receive those values
  def onlyPopulatedFanCmds(container: TempControl_Inputs_Container): B = {
    return container.currentTemp.degrees >= f32"-70.0" && container.currentTemp.degrees <= f32"80.0"
  }

  def exampleSchema(input_container: Any, property_function: Any): B = {
    return T
  }

  def exampleProperty(input_container: Any, output_container: Any): B = {
    return T
  }

  // a pre-state container filter could prove useful/necessary in order to
  // ensure that the values in the container will satisfy the assume/requires clause
  // of a component in the system that will receive those values
  def examplePreStateContainerFilter(container: TempControl_Inputs_Container): B = {
    // e.g. return container.low < container.high
    return T
  }

  def genTestName(config: SystemTestConfiguration): String = {
    return s"${config.name}: ${config.schema.name}: ${config.property.name}: ${config.profile.name}"
  }

  def genTestNameJson(config: SystemTestConfiguration): String = {
    @strictpure def p(str: String): ST = Json.Printer.printString(str)
    return st"""{"name" : ${p(config.name)}, "description" : ${p(config.description)}, "schema": ${p(config.schema.name)}, "property" : ${p(config.property.name)}, "profile" : ${p(config.profile.name)}}"""".render
  }

  override def beforeAll(): Unit = {
    val s = Set.empty[String] ++ (for(c <- configurations) yield c.name)
    assert (s.size == configurations.size, "Configuration names must be unique")
    assert (ops.ISZOps(s.elements).forall(p => !ops.StringOps(p).contains(" ")), "Configuration names cannot contain spaces")

    propStatus = Map.empty
    super.beforeAll()
  }

  val failOnTriviallyTrueProps: B = T

  override def afterAll(): Unit = {
    var msgs: ISZ[String] = ISZ()
    for (p <- propStatus.entries if p._2.triggerT_desiredT == 0) {
      // propStatus has three fields
      //   # of F -> X
      //   # of T -> F  --> the test case would have failed for T -> F so this should be 0
      //   # of T -> T  --> may need to increase # of tests if this is always 0
      msgs = msgs :+ s"Property ${p._1} was trivially true ${p._2.triggerF} times, desired failed ${p._2.triggerT_desiredF} times, and desired was never satisfied"
    }
    if (msgs.nonEmpty) {
      if (failOnTriviallyTrueProps) {
        assert(F, st"${(msgs, "\n")}".render)
      } else {
        cprint(T, st"${(msgs, "\n")}".render)
      }
    }
    super.afterAll()
  }

  def bookKeep(triggerCond: B, desiredCond: B): Unit = {
    val propName = Thread.currentThread().getStackTrace()(2).getMethodName
    val prop = propStatus.getOrElse(propName, PropStatus(0,0,0))
    propStatus = propStatus + propName ~> prop.copy(
      triggerF = prop.triggerF + (if (!triggerCond) 1 else 0),
      triggerT_desiredF = prop.triggerT_desiredF + (if (triggerCond && !desiredCond) 1 else 0),
      triggerT_desiredT = prop.triggerT_desiredT + (if (triggerCond && desiredCond) 1 else 0)
    )
  }

  implicit def toNameProvider1[X](eta: X => B)(implicit line: sourcecode.Line): NameProvider1 = {
    val l = ops.StringOps(lines(line.value - 1))
    return NameProvider1(l.substring(l.lastIndexOf('=') + 2, l.lastIndexOf('_') - 1), eta)
  }

  implicit def toNameProvider2[X, Y](eta: (X, Y) => B)(implicit line: sourcecode.Line): NameProvider2 = {
    val l = ops.StringOps(lines(line.value - 1))
    return NameProvider2(l.substring(l.lastIndexOf('=') + 2, l.lastIndexOf('_') - 1), eta)
  }

  implicit def oneToGen[X](eta: (X) => B): Any => B = eta.asInstanceOf[Any => B]

  implicit def twoToGen[X, Y](eta: (X, Y) => B): (Any, Any) => B = eta.asInstanceOf[(Any, Any) => B]
}

object SystemTests_wSlangCheck {

  case class PropStatus (val triggerF: Z,
                         val triggerT_desiredF: Z,
                         val triggerT_desiredT: Z)

  var propStatus: Map[String, PropStatus] = Map.empty

  val lines: ISZ[String] = {
    val ll: String = Os.env("ABS_JAR_LOC") match {
      case Some(l) =>
        // must be running from the jar file so need to unpack it to get the source files
        val tempDir = Os.tempDir()
        proc"unzip $l -d $tempDir".runCheck()
        val name = ops.ISZOps(ops.StringOps(ops.StringOps(getClass.getName).replaceAllLiterally("$", "")).split(c => c == C('.')))
        val ret = ((tempDir /+ name.dropRight(1)) / s"${name.last}.scala").read
        tempDir.removeAll()
        ret
      case _ => Os.path(implicitly[sourcecode.File].value).read
    }
    ops.StringOps(ops.StringOps(ll).replaceAllLiterally("\n", " \n")).split(c => c == C('\n'))
  }

  @strictpure def p(str: String): ST = Json.Printer.printString(str)

  val dummy = genJsons(F)   // doing this a var decl so that the actions are invoked when the JVM loads the object

  def genJsons(echo: B): B = {
    if (Os.env("JENKINS_HOME").isEmpty) { // don't generate these when CI
      // emit test configs as JSON
      val inst = new Example_TempControl_Inputs_Container_Test_wSlangCheck()
      val entries = for (entry <- inst.configurations) yield inst.genTestNameJson(entry)
      val thisFile = Os.path(implicitly[sourcecode.File].value)
      val outFile = thisFile.up / s"${thisFile.name}.json"
      outFile.writeOver(st"${(entries, "\n")}".render)

      // emit schedule as JSON
      val nickNames: ISZ[ST] = for (e <- inst.scheduler.threadNickNames.entries) yield
        st"${e._1}:${Arch.ad.components(e._2).name}"
      val nickNamesS = st"${(nickNames, ",")}".render
      val revMap = Map.empty[Art.BridgeId, String] ++ (for(e <- inst.scheduler.threadNickNames.entries) yield e._2 ~> e._1)
      val sched: ISZ[ST] = for (e <- inst.scheduler.domainToBridgeIdMap) yield
        st"""${revMap.get(e).get}"""
      val schedS = st"${(sched, ",")}".render
      val schedFile = thisFile.up / s"${thisFile.name}_schedule.json"
      schedFile.writeOver(
        st"""{
            |  "nickNames": ${p(nickNamesS)},
            |  "scheduleProvider": ${p(inst.scheduler.getClass.getName)},
            |  "schedule": ${p(schedS)}
            |}""".render)

      if (echo) {
        println(outFile)
        println(schedFile)
      }
    }

    F
  }
}
